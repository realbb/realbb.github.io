---
layout: single
date: 2020-04-08 11:43:00 +0900
title: 스트라센 알고리즘에 관하여
---



## 서론



스트라센 알고리즘이란 독일의 **"볼커 스트라센"** 이라는 수학자가 고안해낸 알고리즘이다. 

이 알고리즘은 **행렬들의 곱셈**을 할 때 쓰이는 알고리즘으로써, 기존의 행렬 곱셈의 알고리즘보다 **더 효율적인 알고리즘**이라는 평을 듣는다. 

그렇다면 어떤 면에서 더 효율적인지 이 알고리즘에 대해 알아보자



## 행렬의 곱



행렬은 수 또는 변수등을 괄호안에 행 또는 렬의 형태로 정리한 직사각형 모양을 말한다. 
$$
\left[\begin{array}{rrr} 
1&2&3\\
4&5&6\\
\end{array}\right]
$$
만일 두 행렬이 n x m, f x g 의 행과 열을 가지고, m=f 일 경우, 행렬의 곱셈이 가능해진다. 계산 과정은 아래와 같다.
$$
\left[\begin{array}{rrr} 
a&b\\
c&d\\
\end{array}\right] \times
 \left[\begin{array}{rrr} 
e&f\\
g&h\\
\end{array}\right] = \left[\begin{array}{rrr} 
a\times e +b \times g & a\times f +b \times h\\
c\times e +d \times g & c\times f +d \times h\\
\end{array}\right]\\
$$
즉 곱하기 기호 뒤의 행렬은 행을, 기호 앞의 행렬은 열을 기준으로 하여,  각 행렬의 원소끼리 순서대로 곱한것을 모두 합하면 새로운 행렬의 원소로 나오게 된다.



## 행렬의 곱 알고리즘,  계산 횟수



기본적인 행렬의 곱셈 알고리즘은 위와 같이 행과 열을 단순하게 더한 것이 새로운 행렬의 원소가 된다.

이것을 c 언어의 함수로 나타내보자.

A와 B는 곱하고자하는 행렬, C는 곱의 결과인 행렬이다. (n은 행과열의 줄수로써, 간단하게 하고자 정방행렬로 생각하고 코드를 짰다.)

```c
for(int i=0;i<n;i++)
{
    for(int j=0;j<n;j++)
    {
        for(int k=0;k<n;k++)
            C[i][j] += A[i][k] * B[k][i];
	}
}
```

위 코드를 보며 계산횟수에 대해 생각해보자.

결과 행렬인 C의 원소는 행렬 A, B의 각 원소에 대해 곱한 값들을 합친값이다. 

즉 크기가 n x n인 정방행렬의 경우, C의 한 원소에는 n 번의 곱셈, 그것들을 다합한 n-1 번의 덧셈이 있는 셈이다. 

따라서 행렬 C는 **n^3 번의 곱셈, (n-1)n^2 번의 덧셈을 가지며,  총 (2n-1)n^2 의 계산 횟수를 가진다.**







## 스트라센 알고리즘,  계산 횟수



스트라센 알고리즘은 2^n x 2^n 의 정방행렬만 적용할수 있다. 왜냐하면 헹렬의 행과 열이 길이가 1이 될때까지 4부분으로 나누어줘야하기 때문이다.

(만일 2^n x 2^n가 아닌 행렬이라면 0을 추가해줘서 이 형태로 만들고, 계산한 후에 0을 제거하여 원하고자하는  행렬을 얻을 수 있다.)

이 알고리즘에 대해 설명하면,  먼저 아래와 같은 헹렬 곱이 있다하자.


$$
A \times B = C
$$


이제 이 행렬 A와 B를 각각 4부분의 행렬로 나누어주고, 후에 결과를 설명하기 위해 C또한 4부분으로 나누어준다


$$
A =\left[\begin{array}{rrr} 
A_1&A_2\\
A_3&A_4\\
\end{array}\right] \\
B = \left[\begin{array}{rrr} 
B_1&B_2\\
B_3&B_4\\
\end{array}\right]\\
C =  \left[\begin{array}{rrr} 
C_1&C_2\\
C_3&C_4\\
\end{array}\right]
$$


그 후,  이 나누어진 행렬들을 이용해 7개의 행렬을 만들어준다.


$$
M_1=(A_1+A_4)\times(B_1+B_4)
\\
M_2=(A_3+A_4)\times B_1
\\
M_3=A_1\times(B_2+B_4)
\\
M_4=A_4\times(B_3-B_1)
\\
M_5=(A_1+A_2)\times B_4
\\
M_6=(A_3-A_1)\times(B_1+B_2)
\\
M_7=(A_2-A_4)\times(B_3+B_4)
\\
$$




이리 되면 결과 값인 행렬 C의 원소들을 다음과 같은 식으로 정의할수 있어진다.


$$
C_1=M_1 +M_4 - M_5 +M_7

\\
C_2=M_3 +M_5

\\
C_3=M_2 +M_4

\\
C_4=M_1 + M_2 - M_3 +M_6
$$


이렇게 스트라센 알고리즘으로 행렬의 곱을 표현할 수 있다.





이제 이 알고리즘의 계산 횟수에 대해 알아보자.

2 x 2 행렬의 경우, 단순하게 위의 알고리즘에 나온 곱셈과 덧셈의 갯수를 세어주면 된다. 

즉 7번의 곱셈, 18번의 덧셈이 나온다.

4 x 4 행렬의 경우, 한번 4개의 행렬로 나누어 7개의 행렬로 만들어도, 2 x 2행렬이므로, 알고리즘을 한번 더 적용한다. 

따라서 곱셈은 7*7번 일어난다.

하지만 덧셈의 경우에는 7개의 2 x 2 를 만들어서 7*18 번이 끝이 아니다. 2 x 2를 만들어서 알고리즘대로 적용하면 또 다시 18번의 덧셈이 생긴다.

또한, 이 추가적인 18번의 덧셈은 2 x 2의 형태로 이루어지기 때문에 총 4*18번의 덧셈이 추가된다고 보는것이 맞다.


$$
\space7^2+7\times (18) +2^2\times 18=247 (번)
$$


따라서 4 x 4의 행렬 곱의 계산 횟수는 247번 일어난다.



이제 8 x 8의 경우를 알아보자.

8 x 8은 7개의 행렬로 나누면 각각의 연산 횟수는 4 x 4 와 같다.

또한 마지막에 18번의 계산이 추가되지만 4 x 4의 형태므로 2^4 * 18번의 추가 덧셈이 일어난다.


$$
7^3+ 7 \times( 7\times (18) +2^2\times 18)+2^4 \times 18= 2017(번)
$$


따라서 8 x 8의 행렬 곱의 계산 횟수는 2017번 일어난다. 



이것을 표로 바꾸어보자.

| n의 값 |    곱셈의 계산 횟수    |                   덧셈의 계산 횟수                   |
| :----: | :--------------------: | :--------------------------------------------------: |
|   2    |           7            |                          18                          |
|   4    |          7^2           |                  7 x (18)+2^2 x 18                   |
|   8    |          7^3           |          7 x (7 x (18)+2^2 x 18) + 2^4 x 18          |
|  ...   |          ...           |                         ...                          |
|   n    | 7^(log (n) / log (2) ) | 7 x (n=(log(현재 n) / log(2)일 때의 횟수))+2^(n/2)^2 |



즉 n일 때 총 계산 횟수를 정리하면 아래와 같다

![](https://user-images.githubusercontent.com/62462277/79050649-7b939780-7c66-11ea-9467-1209019f6637.jpg)

이것을 점화식으로 정리를하면 

![점화식 총 정리](https://user-images.githubusercontent.com/62462277/79052746-8ef92f80-7c73-11ea-9f82-368c3211538d.jpg)

와 같다.



(마크다운 문법인 sub, sup으로 식을 세울려 했으나 번거롭고 식의 모양이 예쁘지 않아 사진으로 올립니다. 양해부탁드립니다.)



## 스트라센 알고리즘의 의의 (그래프)

행렬 곱 알고리즘과 스트라센 알고리즘의 결과를 알아보았다.

그렇다면, 만약 이 스트라센 알고리즘이 정말 효율적이라면, 

계산 횟수를 줄여주지 않았을까?

이것이 참이라면 아래의 식이 만족해야한다

(행렬 곱 알고리즘의 점화식) - (스트라센 알고리즘 점화식)  > 0

이것을 그래프로 통해서 알아보자.

식을 입력할 경우, 그래프를 그려주는 사이트를 사용했다.

[https://www.desmos.com/calculator](https://www.desmos.com/calculator)

사이트에 들어가 점화식끼리 빼준 식을 입력해주자. (n을 x라고 바꾸었다.)

![](https://user-images.githubusercontent.com/62462277/79052976-fa8fcc80-7c74-11ea-825d-e6385bc7e24c.png)


이제 정말로 계산횟수를 줄여준다면 이 그래프는 0보다 큰 값을 가지는 구간이 존재해야한다.

![](https://user-images.githubusercontent.com/62462277/79053110-be10a080-7c75-11ea-8fc2-c5b1e77cea4c.png)

처음에는 그저 아래로 뻗는 그래프 밖에 보이지 않는다.

하지만 x의 값이 아래와 같이 도달하면, 그래프는 위로 향해 뻗는다.

![](https://user-images.githubusercontent.com/62462277/79053164-1b0c5680-7c76-11ea-80a4-a243f70c9e26.png)



그리고 마침내 이 그래프는 x=654 쯤에서 0의 값을 갖는다.

![](https://user-images.githubusercontent.com/62462277/79053222-aede2280-7c76-11ea-8f1c-97793adb1e74.png)


이 이후에는 다시 0으로 가지 않는다.

(그래프에서 x가 음수를 다루지 않는 이유는, log의 진수는 음수가 되면 안되기 때문이다. 또한 상식적으로 음수의 갯수를 갖는 행렬은 존재하지 않는다.)



## 그래프에서 음수의 값이 왜 생겼을까?

스트라센 알고리즘은 **곱셈의 연산을 줄여주고 덧셈의 연산을 추가**해주었다.

이것이 초반엔 (1~654) 악영향을 끼쳐 오히려 **연산의 횟수를 늘리는 현상**을 만든 것이다.

그러나 **n 값이 커질수록** 스트라센 알고리즘을 쓰며 **늘어나는 덧셈의 연산 횟수보다, 줄어드는 곱셈의 연산횟수가 더 크기때문에**, 양수의 값이 나오며 효율적인 알고리즘이라는 근거가 생긴것이다.

실제로 (행렬 곱 알고리즘의 곱셈의 횟수) - (스트라센 알고리즘의 곱셈 횟수) 의 그래프를 그리면 아래와 같이 크게 증가하는 그래프가 나온다.

![](https://user-images.githubusercontent.com/62462277/79053758-940dad00-7c7a-11ea-8367-a4a37befe937.png)



(0과 1사이의 영역에서 음수인 결과값은 무시한다. 행렬의 갯수가 소수일 수는 없으므로.)



## 덧셈과 곱셈의 실행시간

 컴퓨터는 사칙계산을 할 때, 수를 먼저 이진수로 처리한 후에 계산을 한다.

아래의 사진에서 왼쪽의 식은 덧셈, 오른쪽의 식은 곱셈이다.

![](https://user-images.githubusercontent.com/62462277/79054369-316ae000-7c7f-11ea-9e31-5d1ed117aa4f.jpg)



왼쪽의 덧셈을 먼저보면 각 비트별로 더하여 캐리가 생길 경우 다음의 비트로 넘어가 그 비트에서 계산해준다. 이때 덧셈의 결과와 캐리의 여부는 and게이트와 or 게이트로 판단이 가능하다.



오른쪽의 곱셈에서는 첫 번째 피연산자를 피승수, 두 번쨰 피연산자를 승수라고 한다.

이 때 곱셈에서는 값을 낼 때, 2가지의 경우가 있다.

1. 승수의 자리 수가 0일 경우, 결과값의 자리에는 0이 온다.
2.  승수의 자리 수가 1일 경우, 결과값의 자리에는 1이 온다.

위의 곱셈식을 보면 자릿수에 맞게  한 칸씩 옆으로 밀리게 해주고, 후에 덧셈을 취해준 것이 보인다.

이렇게 옆으로 이동해주는 것을 자리이동 (shift) 이라고 해준다.

즉 곱셈은 덧셈의 알고리즘 뿐만 아니라, 자리이동을 해주는 알고리즘 역시 필요하기 때문에 실행시간이 좀더 길어진다.

이것을 스트라센 알고리즘에 연관지어 생각해본다면,  스트라센 알고리즘은 위의 그래프에서 결론나온 것과 같이 곱셈의 횟수를 줄여준다.

그런데 **심지어 덧셈보다 곱셈의 실행시간이 조금 더 길다면, 이 곱셈의 횟수를 줄여주는 알고리즘은 위의 그래프의 결과보다 더 일찍 효율적인 알고리즘이라는 말이 된다!**



## 결론

행렬 곱의 알고리즘과 스트라센 알고리즘을 비교했을 때, 

그래프에서 보았다시피 n의 값이 작을 때는 스트라센 알고리즘을 적용하는 것이 손해이다.

하지만, n의 값이 커짐에 따라 아래의 장점들이 생긴다.



1. **스트라센 알고리즘을 쓸 때 증가하는 덧셈의 횟수보다 줄어드는 곱셈의 횟수가 더 커진다.**
2. **덧셈보다 곱셈의 실행시간이 조금 더 큰 것을 감안해 곱셈의 횟수를 줄이는 것이 최적화에 가까운 길이다.** (따라서 1. 의 장점을 더욱 극대화 시켜준다)



이런 점들로 보아 스트라센의 알고리즘은 정말 위대한 발명이다.



## 의문점

1. 수학자 스트라센은 이 알고리즘을 어떤 계기로 인해 이 알고리즘을 만들어낼 수 있었을까?
2.  현재 스트라센 알고리즘보다 더 효율적이라는 위노그라드 알고리즘까지 나온 상황이다. 이것의 시간복잡도는 (n^2.37)이라고 한다. 그렇다면 이 알고리즘들 보다 뛰어난 알고리즘들이 탄생할 수 있을까?