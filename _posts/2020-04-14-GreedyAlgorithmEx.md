---
layout: single
date: 2020-04-14 11:43:00 +0900
title: 그리디 알고리즘
---



## 그리디 알고리즘

**그리디 알고리즘**이란 선택의 순간마다 현재 상황에서 보았을 때 최고의 이익만을 골라서 선택하는 알고리즘을 말한다.

물론 매 순간마다 최고의 선택을 하는 것이 전체적으로 보았을 때, 제일 큰 이득일 가능성도 있지만, 그렇지 않을 때도 있어 언제나 어울리는 최적의 알고리즘은 아니다.



예를 들어 어떤 소비자가 590원짜리 물건을  1000원을 주고 산다고 가정하자.

동전의 종류는 500,170,100,10 원 짜리로 이루어졌다고 하자.(170원 동전은 원래 없지만...)

이 소비자는 거스름돈을 받는것에 그리디 알고리즘을 적용해보자.

 1000-590 =  410 원의 거스름돈을 받아야한다.

현재 500원보다 낮다. 그러므로 500원 짜리동전은 0개이다.

410 - x*170 >= 0 을 만족하는 최대의 x는 2다.

그러므로 사용한 170원 짜리 동전은 2개, 남은 잔돈은 70원이다.

남은 70원을 10원 짜리로 처리해주면 7개로 처리할 수 있다.

정리하면 410원을 170원 짜리 2개, 10원짜리 7개로 줄 수 있다.

하지만, 직관적으로 보았을 때, 우리는 100원짜리 4개, 10원짜리 1개로 주면 더 적은 동전을 사용하며 거스름돈을 줄 수 있다는 것을 안다.

이런점에서 그리디 알고리즘이 최적이 아니다라고 말한다.



## 그리디 알고리즘 예제

이 예제는 2006년의 대학생 프로그래밍 경시대회에서 나온 문제이다.

### 1. 문제 설명

A회사는 다른 회사와 딱히 다를 바 없이 서류 심사와 면접시험을 거친 후, 인재 선발이 이루어진다. 

허나 이 회사는 최고의 인재들로만 이루어지길 바란다.

그래서 이 회사는 어떤 사람의 서류심사와 면접시험의 성적 중 **적어도 하나가** 모든 다른 사람들과 비교했을 때, 뒤쳐지지 않아야만 선발 하는 제도가 있다.

예를 들어 a라는 사람이 서류, 면접에서 1,4 등을 하고, b라는 사람이 서류, 면접에서 5,1등 을 했다하면, b는 서류에서 a에게 밀리지만 면접에서는 우세하므로 둘 다 뽑힌다는 말이다.

이런 회사에 N명의 사람들이 지원 할 경우, A회사는 최대 몇명을 인재 선발로 뽑는 것이 가능할까?



### 2. 입력

먼저 테스트 케이스의 갯수를 입력 (1 <= T <= 20)

각 케이스마다의 지원자 수를 입력

케이스 안의 지원자 수 만큼 서류, 면접 시험의 순위를 입력



### 3. 출력

각 케이스마다 입력이 끝나면 최대로 선발할 수 있는 인재의 수 출력



## 예제 접근법

물론 사람의 눈으로 비교하면 서류, 면접에서의 각 1등을 먼저 뽑고, 각각 2등들을 비교해나가며 풀 수 있을 것이다.

하지만 컴퓨터로는 그런 직관적인 풀이가 어려우므로 알고리즘을 생각해내야한다.

먼저 서류심사의 1등은 무조건 뽑힌다. (1등이상은 없으므로)

그다음에 서류 심사의 2등을 보자, 만약 서류심사의 2등이 1등보다 면접 시험의 등수가 높다면, 이 사람 또한 선발된다.

서류 면접의 3등 역시 서류 면접의 1,2등보다 면접 시험의 등수가 더 높으면, 뽑히는 것이다.

정리하자면 서류 심사의 등수 기준으로, 아랫 등수의 사람이 윗 등수사람보다 면접 시험을 더 높게 받은 사람을 **모두 다** 뽑는다면 그 수가 최대의 인원이 될 것이다.



## 내가 구현한 예제의 코드

자바로 구현한 내 코드이다.

1. 먼저 서류와 면접의 등수를 배열에 입력한다.

2. 서류의 등수를 성적순으로 배열을 정리해준다.
3. 정수 변수인 highest_Interview에 서류 1등의 면접 점수를 넣는다.

4. 그리디 알고리즘에 따라 면접시험의 등수를 비교해나가며 highest_Interview를 업데이트해주며 선발한다.

부가 설명은 주석으로 표시했다.

```java
import java.util.*;

class employee
{
    int Document;
    int Interview;
}


public class Main {
    public static void main(String[] args)
    {
        Scanner sc = new Scanner((System.in));
        int testcase;
        employee arr[]=new employee[100000];
        int N;
        int selected_employee;

        employee swap=new employee();
        int highest_Interview;

        testcase=sc.nextInt();

        for(int q=0;q<testcase;q++)  // 테스트 케이스 반복
        {

            selected_employee=1;// 뽑힌 사원의 수 , 서류면접의 1등은 무조건 뽑히므로 1

            N=sc.nextInt();  // 지원한 사람 수

            for(int j=0;j<N;j++)  // 한 케이스의 성적 입력
            {
                arr[j]= new employee();
                arr[j].Document=sc.nextInt();
                arr[j].Interview=sc.nextInt();
            }

              //배열 서류심사 기준으로 정리
            for(int i=0;i<N;i++)
            {
                for(int j=i+1;j<N;j++)
                {
                    if(arr[i].Document > arr[j].Document)
                    {
                        swap = arr[j];
                        arr[j]= arr[i];
                        arr[i]=swap;
                    }
                }
            }

            highest_Interview=arr[0].Interview;

            for(int i=1;i<N;i++)
            {
                if(highest_Interview>arr[i].Interview)
                {
                    selected_employee++;   // 뽑힌 사원 증가
                    highest_Interview=arr[i].Interview;
                }
            }
            System.out.println(selected_employee);

        }
    }
}
```



다음은 출력창이다.

![](https://user-images.githubusercontent.com/62462277/79442531-a0e02700-8013-11ea-818a-42c0c53797f0.png)





## 의문점

2가지의 시험점수에 따른 선발은 그리디 알고리즘으로 매우 쉽게 구해낼 수 있었다.

하지만 실제로는 서류, 면접 말고도 다른 요인으로 등수가 매겨질 수 있다.

즉, 2가지의 시험점수의 갯수가 3개, 4개, 5개..... 증가할 때도 그리디 알고리즘을 적용시킬수 있을까?



문제 출처: /[http://icpckorea.org/](http://icpckorea.org/)

문제 pdf:  [2006od.pdf](https://github.com/realbb/realbb.github.io/files/4486313/2006od.pdf) 